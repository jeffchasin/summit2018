'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var PARENT = 'parent';
var CHILD = 'child';
var HANDSHAKE = 'handshake';
var HANDSHAKE_REPLY = 'handshake-reply';
var CALL = 'call';
var REPLY = 'reply';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var MESSAGE = 'message';
var DATA_CLONE_ERROR = 'DataCloneError';

var DEFAULT_PORTS = {
  'http:': '80',
  'https:': '443'
};

var URL_REGEX = /^(https?:)?\/\/([^\/:]+)(:(\d+))?/;

var Penpal = {
  /**
   * Promise implementation.
   * @type {Constructor}
   */
  Promise: function () {
    try {
      return window ? window.Promise : null;
    } catch (e) {
      return null;
    }
  }(),
  /**
   * Whether debug messages should be logged.
   * @type {boolean}
   */
  debug: false
};

/**
 * @return {number} A unique ID (not universally unique)
 */
var generateId = function () {
  var id = 0;
  return function () {
    return ++id;
  };
}();

/**
 * Logs a message.
 * @param {...*} args One or more items to log
 */
var log = function log() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (Penpal.debug) {
    var _console;

    (_console = console).log.apply(_console, ['[Penpal]'].concat(args)); // eslint-disable-line no-console
  }
};

/**
 * Converts a URL into an origin.
 * @param {string} url
 * @return {string} The URL's origin
 */
var getOriginFromUrl = function getOriginFromUrl(url) {
  var location = document.location;

  var regexResult = URL_REGEX.exec(url);
  var protocol = void 0;
  var hostname = void 0;
  var port = void 0;

  if (regexResult) {
    // It's an absolute URL. Use the parsed info.
    // regexResult[1] will be undefined if the URL starts with //
    protocol = regexResult[1] ? regexResult[1] : location.protocol;
    hostname = regexResult[2];
    port = regexResult[4];
  } else {
    // It's a relative path. Use the current location's info.
    protocol = location.protocol;
    hostname = location.hostname;
    port = location.port;
  }

  // If the port is the default for the protocol, we don't want to add it to the origin string
  // or it won't match the message's event.origin.
  return protocol + '//' + hostname + (port && port !== DEFAULT_PORTS[protocol] ? ':' + port : '');
};

/**
 * A simplified promise class only used internally for when destroy() is called. This is
 * used to destroy connections synchronously while promises typically resolve asynchronously.
 *
 * @param {Function} executor
 * @returns {Object}
 * @constructor
 */
var DestructionPromise = function DestructionPromise(executor) {
  var handlers = [];

  executor(function () {
    handlers.forEach(function (handler) {
      handler();
    });
  });

  return {
    then: function then(handler) {
      handlers.push(handler);
    }
  };
};

/**
 * Creates an object with methods that match those defined by the remote. When these methods are
 * called, a "call" message will be sent to the remote, the remote's corresponding method will be
 * executed, and the method's return value will be returned via a message.
 * @param {Object} info Information about the local and remote windows.
 * @param {Array} methodNames Names of methods available to be called on the remote.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Object} An object with methods that may be called.
 */
var createCallSender = function createCallSender(info, methodNames, destructionPromise) {
  var localName = info.localName,
      local = info.local,
      remote = info.remote,
      remoteOrigin = info.remoteOrigin;

  var destroyed = false;

  log(localName + ': Creating call sender');

  var createMethodProxy = function createMethodProxy(methodName) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      log(localName + ': Sending ' + methodName + '() call');
      return new Penpal.Promise(function (resolve, reject) {
        if (destroyed) {
          reject('Unable to send ' + methodName + '() call due to destroyed connection');
          return;
        }

        var id = generateId();
        var handleMessageEvent = function handleMessageEvent(event) {
          if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === REPLY && event.data.id === id) {
            log(localName + ': Received ' + methodName + '() reply');
            local.removeEventListener(MESSAGE, handleMessageEvent);
            (event.data.resolution === FULFILLED ? resolve : reject)(event.data.returnValue);
          }
        };

        local.addEventListener(MESSAGE, handleMessageEvent);
        remote.postMessage({
          penpal: CALL,
          id: id,
          methodName: methodName,
          args: args
        }, remoteOrigin);
      });
    };
  };

  destructionPromise.then(function () {
    destroyed = true;
  });

  return methodNames.reduce(function (api, methodName) {
    api[methodName] = createMethodProxy(methodName);
    return api;
  }, {});
};

/**
 * Listens for "call" messages coming from the remote, executes the corresponding method, and
 * responds with the return value.
 * @param {Object} info Information about the local and remote windows.
 * @param {Object} methods The keys are the names of the methods that can be called by the remote
 * while the values are the method functions.
 * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal
 * connection.
 * @returns {Function} A function that may be called to disconnect the receiver.
 */
var connectCallReceiver = function connectCallReceiver(info, methods, destructionPromise) {
  var localName = info.localName,
      local = info.local,
      remote = info.remote,
      remoteOrigin = info.remoteOrigin;

  var destroyed = false;

  log(localName + ': Connecting call receiver');

  var handleMessageEvent = function handleMessageEvent(event) {
    if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === CALL) {
      var _event$data = event.data,
          methodName = _event$data.methodName,
          args = _event$data.args,
          id = _event$data.id;


      log(localName + ': Received ' + methodName + '() call');

      if (methodName in methods) {
        var createPromiseHandler = function createPromiseHandler(resolution) {
          return function (returnValue) {
            if (destroyed) {
              // We have to throw the error after a timeout otherwise we're just continuing
              // the promise chain with a failed promise.
              setTimeout(function () {
                throw new Error('Unable to send ' + methodName + '() reply due to destroyed connection');
              });
              return;
            }

            log(localName + ': Sending ' + methodName + '() reply');

            try {
              remote.postMessage({
                penpal: REPLY,
                id: id,
                resolution: resolution,
                returnValue: returnValue
              }, remoteOrigin);
            } catch (err) {
              // If a consumer attempts to send an object that's not cloneable (e.g., window),
              // we want to ensure the receiver's promise gets rejected.
              if (err.name === DATA_CLONE_ERROR) {
                remote.postMessage({
                  penpal: REPLY,
                  id: id,
                  resolution: REJECTED,
                  returnValue: err.toString()
                }, remoteOrigin);
              }

              setTimeout(function () {
                throw err;
              });
            }
          };
        };

        new Penpal.Promise(function (resolve, reject) {
          try {
            // The consumer's function may throw an error, return a raw return value, return
            // a promise that resolves, or return a promise that gets rejected.
            // In the case that it throws an error, we'll send the error stack as a reply
            resolve(methods[methodName].apply(methods, _toConsumableArray(args)));
          } catch (err) {
            reject(err.toString());
            setTimeout(function () {
              throw err;
            });
          }
        }).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));
      }
    }
  };

  local.addEventListener(MESSAGE, handleMessageEvent);

  destructionPromise.then(function () {
    destroyed = true;
    local.removeEventListener(MESSAGE, handleMessageEvent);
  });
};

/**
 * @typedef {Object} Child
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 * @property {HTMLIframeElement} iframe The created iframe element.
 * @property {Function} destroy A method that, when called, will remove the iframe element from
 * the DOM and clean up event listeners.
 */

/**
 * Creates an iframe, loads a webpage into the URL, and attempts to establish communication with
 * the iframe.
 * @param {Object} options
 * @param {string} options.url The URL of the webpage that should be loaded into the created iframe.
 * @param {HTMLElement} [options.appendTo] The container to which the iframe should be appended.
 * @param {Object} [options.methods] Methods that may be called by the iframe.
 * @return {Child}
 */
Penpal.connectToChild = function (_ref) {
  var url = _ref.url,
      appendTo = _ref.appendTo,
      _ref$methods = _ref.methods,
      methods = _ref$methods === undefined ? {} : _ref$methods;

  var destroy = void 0;
  var destructionPromise = new DestructionPromise(function (resolve) {
    return destroy = resolve;
  });

  var parent = window;
  var iframe = document.createElement('iframe');

  (appendTo || document.body).appendChild(iframe);

  destructionPromise.then(function () {
    if (iframe.parentNode) {
      iframe.parentNode.removeChild(iframe);
    }
  });

  var child = iframe.contentWindow || iframe.contentDocument.parentWindow;
  var childOrigin = getOriginFromUrl(url);
  var promise = new Penpal.Promise(function (resolve, reject) {
    var handleMessage = function handleMessage(event) {
      if (event.source === child && event.origin === childOrigin && event.data.penpal === HANDSHAKE) {
        log('Parent: Received handshake');

        parent.removeEventListener(MESSAGE, handleMessage);

        log('Parent: Sending handshake reply');

        event.source.postMessage({
          penpal: HANDSHAKE_REPLY,
          methodNames: Object.keys(methods)
        }, event.origin);

        var info = {
          localName: PARENT,
          local: parent,
          remote: child,
          remoteOrigin: event.origin
        };

        connectCallReceiver(info, methods, destructionPromise);
        resolve(createCallSender(info, event.data.methodNames, destructionPromise));
      }
    };

    parent.addEventListener(MESSAGE, handleMessage);
    destructionPromise.then(function () {
      parent.removeEventListener(MESSAGE, handleMessage);
      reject('Parent: Connection destroyed');
    });

    log('Parent: Loading iframe');
    iframe.src = url;
  });

  return {
    promise: promise,
    iframe: iframe,
    destroy: destroy
  };
};

/**
 * @typedef {Object} Parent
 * @property {Promise} promise A promise which will be resolved once a connection has
 * been established.
 */

/**
 * Attempts to establish communication with the parent window.
 * @param {Object} options
 * @param {string|Array} [options.parentOrigin] Valid parent origin used to restrict communication
 * An array of parent origin strings is also supported.
 * @param {Object} [options.methods] Methods that may be called by the parent window.
 * @return {Parent}
 */
Penpal.connectToParent = function (_ref2) {
  var parentOrigin = _ref2.parentOrigin,
      _ref2$methods = _ref2.methods,
      methods = _ref2$methods === undefined ? {} : _ref2$methods;

  var destroy = void 0;
  var destructionPromise = new DestructionPromise(function (resolve) {
    return destroy = resolve;
  });

  var child = window;
  var parent = child.parent;
  var targetParentOrigin = getOriginFromUrl(document.referrer);

  if (parentOrigin !== undefined && !Array.isArray(parentOrigin)) {
    parentOrigin = [parentOrigin];
  }

  if (parentOrigin !== undefined && parentOrigin.indexOf(targetParentOrigin) === -1) {
    throw new Error('Child: parent\'s origin not in list of valid parent origins');
  }

  var promise = new Penpal.Promise(function (resolve, reject) {
    var handleMessageEvent = function handleMessageEvent(event) {
      if ((parentOrigin === undefined || parentOrigin.indexOf(event.origin) !== -1) && event.source === parent && event.data.penpal === HANDSHAKE_REPLY) {
        log('Child: Received handshake reply');

        child.removeEventListener(MESSAGE, handleMessageEvent);

        var info = {
          localName: CHILD,
          local: child,
          remote: parent,
          remoteOrigin: event.origin
        };

        connectCallReceiver(info, methods, destructionPromise);
        resolve(createCallSender(info, event.data.methodNames, destructionPromise));
      }
    };

    child.addEventListener(MESSAGE, handleMessageEvent);

    destructionPromise.then(function () {
      child.removeEventListener(MESSAGE, handleMessageEvent);
      reject('Child: Connection destroyed');
    });

    log('Child: Sending handshake');

    parent.postMessage({
      penpal: HANDSHAKE,
      methodNames: Object.keys(methods)
    }, targetParentOrigin);
  });

  return {
    promise: promise,
    destroy: destroy
  };
};

exports.default = Penpal;