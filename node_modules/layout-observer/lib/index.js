'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// List of events that could potentially change layout without triggering a mutation observer.
// Inspired by https://github.com/davidjbradshaw/iframe-resizer/blob/86daa57745f630385e3eb6b03af02dac49d8b777/src/iframeResizer.contentWindow.js#L291-L310
var EVENT_TYPES = ['resize', 'animationstart', 'webkitAnimationStart', 'animationiteration', 'webkitAnimationIteration', 'animationend', 'webkitAnimationEnd', 'input', 'mouseup', 'mousedown', 'orientationchange', 'afterprint', 'beforeprint', 'readystatechange', 'touchstart', 'touchend', 'touchcancel', 'transitionstart', 'webkitTransitionStart', 'MSTransitionStart', 'oTransitionStart', 'otransitionstart', 'transitioniteration', 'webkitTransitionIteration', 'MSTransitionIteration', 'oTransitionIteration', 'otransitioniteration', 'transitionend', 'webkitTransitionEnd', 'MSTransitionEnd', 'oTransitionEnd', 'otransitionend'];

// Derived from http://stackoverflow.com/a/27078401/459966 which is derived from underscore.
// This differs from the one in stackoverflow because it's optimized by removing the options object
// and always assuming the defaults.
var throttle = function throttle(func, wait) {
  var context, args, result;
  var timeout = null;
  var previous = 0;
  var later = function later() {
    previous = Date.now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  return function () {
    var now = Date.now();
    var remaining = wait - (now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };
};

var masterObserver = function () {
  var observing = false;
  var connectedHandlers = [];

  var callHandlers = function callHandlers() {
    connectedHandlers.forEach(function (handler) {
      handler();
    });
  };

  var mutationObserver = new MutationObserver(callHandlers);

  var loadHandler = function loadHandler(event) {
    var target = event.target;
    if (target.tagName === 'IMG') {
      callHandlers();
    }
  };

  var hasDOMContentLoaded = function hasDOMContentLoaded() {
    return document.readyState === 'interactive' || document.readyState === 'complete';
  };

  var startObservations = function startObservations() {
    mutationObserver.observe(document.body, {
      attributes: true,
      attributeOldValue: false,
      characterData: true,
      characterDataOldValue: false,
      childList: true,
      subtree: true
    });

    EVENT_TYPES.forEach(function (eventType) {
      window.addEventListener(eventType, callHandlers);
    });

    // Watch for images and similar resources to load. Load events don't bubble so we must
    // use capture. We can't add the event listener to body because "For legacy reasons, load
    // events for resources inside the document (e.g., images) do not include the Window in the
    // propagation path in HTML implementations"
    document.body.addEventListener('load', loadHandler, true);
  };

  var domContentLoadedHandler = function domContentLoadedHandler() {
    startObservations();
    callHandlers();
  };

  var observe = function observe() {
    if (!observing) {
      observing = true;

      if (hasDOMContentLoaded()) {
        startObservations();
      } else {
        // When the DOM content has loaded, we can start observations because we have access to
        // the necessary DOM element
        document.addEventListener('DOMContentLoaded', domContentLoadedHandler);
      }
    }
  };

  var disconnect = function disconnect() {
    if (observing) {
      observing = false;

      mutationObserver.disconnect();

      document.removeEventListener('DOMContentLoaded', domContentLoadedHandler);

      EVENT_TYPES.forEach(function (eventType) {
        window.removeEventListener(eventType, callHandlers);
      });

      if (document.body) {
        // In case disconnect is called before DOMContentLoaded.
        document.body.removeEventListener('load', loadHandler, true);
      }
    }
  };

  return {
    connectHandler: function connectHandler(handler) {
      if (connectedHandlers.indexOf(handler) === -1) {
        connectedHandlers.push(handler);
      }

      observe();
    },
    disconnectHandler: function disconnectHandler(handler) {
      var index = connectedHandlers.indexOf(handler);

      if (index !== -1) {
        connectedHandlers.splice(index, 1);

        if (!connectedHandlers.length) {
          disconnect();
        }
      }
    }
  };
}();

var LayoutObserver = function LayoutObserver(handler, options) {
  if (options && options.throttle) {
    this.handler = throttle(handler, options.throttle);
  } else {
    this.handler = handler;
  }
};

LayoutObserver.prototype.observe = function () {
  masterObserver.connectHandler(this.handler);
};

LayoutObserver.prototype.disconnect = function () {
  masterObserver.disconnectHandler(this.handler);
};

exports.default = LayoutObserver;